# Zusammenfassung
Im Rahmen der Aufgaben wurde sich mit Regexen, regulärer Grammatik beschäftigt: Ableitung der von gegebenen regulären Ausdrücken beschriebenen Sprache (A1.1), Konstruktion eines präzisen Bezeichner-Regex mit zugehörigem DFA und regulärer Grammatik für eine Programmiersprachen, lexigrafische Darstellung von Gleitkommazahlen für Python und Java (ebenfalls als Regex, DFA, Reguläre Grammatik), Kritik und Verbesserung eines E-Mail-Regex, Entwurf eines DFA für die vorgegebene Bedingung "zweitletzter Buchstabe = zweiter Buchstabe“, sowie die Interpretation einer regulären Grammatik und Ableitung eines äquivalenten Regexes und DFAs.

# Details
Besonders interessant war für mich die Erkenntniss, wie komplex scheinbar einfache Sprachdefinitionen werden können, sobald man versucht, sie formal in reguläre Ausdrücke oder Automaten zu übersetzen. Besonders bei Aufgabe 3 zeigte sich, dass jede zusätzliche Bedingung – etwa „nicht mit Unterstrich enden“ oder „Entweder .f, f.f, .f“ – direkt große Auswirkungen auf die Form des DFA hat. Ich musste Übergänge so anpassen, durcg letzter Bedingung musste bzw. der Teil-Automat für die Ziffernkette 2 Mal ausgeführt werden im DFA, einmal für Floats der Form ".f", einmal der Form "f. oder f.f". Interessant war außerdem der Vergleich zwischen den 2 Programmiersprachen: Java erlaubt bspw. Sequenzen von Unterstrichen beliebiger Länge (zB. "00___1__2.3_2"), währendPython nur 1 Unterstrich zwischen 2 Ziffern erlaubt (zB. "00_1_2.3_2").  Auch Aufgabe 4 war interressant, da man hier sieht, wie umfangreich lexigrafische Regeln in der Praxis dann tatsächlich sein können. So würde eine wirklich robuste Version des Regexes einige Zeilen umfassen, die ich im Rahmen der Aufgabe mit zumutbarem Rechercheaufwand unmöglich umsetzten könnte.

# Reflexion
Die herausforderndste Aufgabe war wohl die präzise Formulierung der Float-Regexe / -DFAs und vor allem die Grammatik, ohne zugleich ungültige Formen zu akzeptieren. insbesondere die Steuerung von optionalen Segmenten (Vorkomma, Nachkomma, Exponent, Typ­suffix) war zunächst nicht ganz klar. Auch die Aufteilung des Float-Ausdrucks in immer genau 1 Nichterminal und 1 Terminal war zunächst nicht ganz einfach, aber ich konnte das lösen, indem ich zunächst eine Unreguläre Gramatik mit mehreren Nichterminalen notiert habe, dann schrittweise modularisiert in Unterregeln (Absolutwert, Int-, Float-Fraktionen, Exponent, Typkennung (nur bei Java-Float)). Geholfen hat hier auch, die Gramatik mit komplexen Testwörter zu testen (zB. "-.1_3e-0_2", "0__1_2.e2d"). Außerdem hat die Visualisierung als DFA oft geholfen.

# Erfahrung
Vor allem über Reguläre Grammatiken konnte ich sehr viel lernen, aber auch über Formelle Grammatiken allgemein konnte ich durch die Bearbeitung der Aufgaben etwas lernen. Allen vorran die praktische Umsetzung einer solchen Grammatik konnte erstmals ausprobiert und geübt werden. Aber auch an der Umsetzung von DFAs konnte ich im Berecih Compilerbau bzw. Lexigrafische Analyse lernen.

# Team
Ich habe allein gearbeitet.
